# Первая часть задания

**Начальная загрузка:**
small.json - 9.94s
medium.json - 83.75s
large.json - предположительно 9 x 83.75s

**Гипотезы:** 
В большом файле:
Городов - небольшое количество (мало)
Сервисов - небольшое количество (мало)
Автобусов - среднее количество
Путешествий - много
Сервисов в автобусах  - много

Включил логирование запросов

На 1 вставку происходит:
2 - 6 запросов на получение / вставку городов 
0 - > 10 запросов на получение / вставку сервисов
4 - > 10 запросов на получение / вставку автобусов

Проверил гипотезу о количестве:
    городов в большом файле: их 10 шт.
    сервисов в большом файле: их 10 шт.
    автобусов в большом файле: их 1 000 шт.

**После загрузки small.json**
buses: 613
cities: 10
services: 10
trips: 1 000
buses_services: 2 632

**После загрузки medium.json**
buses: 1 000
cities: 10
services: 10
trips: 10 000
buses_services: 4 685


1) Оптимизировать количество запросов закешировав города и сервисы для вставки
    **Первая оптимизация**
    small.json - 6.83(1.45X)
    medium.json - 42.50s (1.9X)
    
2) Оптимизировать количество запросов при добавлении автобуса
    автобус один и набор сервисов в нем одинаков, нет нужды все время его пересоздавать
     
3) Сделаем вставку buses_services большими кусками.
    Для этого сформируем один большой кусок данных для вставки и вставим их после обработки всех данных.
    Буду использовать гем activerecord-import
     
    **Третья оптимизация**
    small.json - 1.34s (7.41X)
    medium.json - 7.51s (11.15X)
    large.json - 63.71s

4) У нас до сих пор происходят множественные отдельные вставки трипов (и это бэд трип), поэтому оптимизируем этот момент
    Для этого так же сформируем кусок данных для вставки и вставим одним запросом (как настоящие хакеры).
    
    **Четвертая оптимизация**
    small.json - 0.61s (16.29X)
    medium.json - 1.43s (58.56X)
    large.json - 5.74s

5) Все еще есть проблема с отдельными вставками автобусов.
    Решим ее тем же способом - сформируем данные и импортируем одним запросом.
    Для этого потребуется импортировать все сущности таким способом.
    Так же для ускорения вставки отключил валидации.
    
    Перекладываю валидацию уникальности номера на БД -> добавим ключ на уникальность.
    Так же сразу добавил индексы для поиска.
    
    Идеально создать отдельные валидаторы для валидации данных и прогонять их по вставляемым данным.
    Но будем считать что они консистентны )     
    
    **Пятая оптимизация**
    small.json - 0.23s (43.21X)
    medium.json - 0.83s (100.9X)
    large.json - 7.47s

Итого есть два варианта вставки: 
    полностью батчами (utils.rake) и 
    частично батчами (utils_0.rake), частичный вариант немного быстрее (!)


# Вторая часть задания

Делаю по фен шую - установил rack-mini-profiler, meta-request, strong-migrations, bullet, pghero (бомба)

Загрузил данные из файла large.json
На странице рендерится 1004 рейсов 

Первичный взгляд на профайлинг показал:
 - Присутствует рендеринг в цикле
 - Есть N + 1 запрос: 650 запросов при рендеринге trips/index
 
Оптимизируем количество запросов
Рендеринг занимал: 29.419s

**Первая оптимизация**
Убрал N + 1 запрос
9.456s (3.11X)

Оптимизируем шаблоны
**Вторая оптимизация**
5.411s (5.43X)

**Третья оптимизация**
Еще сильнее оптимизируем шаблоны - избегаем лишних включений.
Благо у нас шаблоны - очень простые )
0.629s (15X)

### Далее нужно добавить кеширование, пейджер - и будет просто космос )
